import { NextRequest, NextResponse } from 'next/server';

type BaseRow = Record<string, any>;
type TopicoV2 = {
  id: string;
  nombre: string;
  volumen: number;
  categoria: string;
  pilar: string;
  coords?: { x: number; y: number };
};

function hashToUnit(seed: string, salt = '') {
  let h = 2166136261 >>> 0;
  const s = seed + '|' + salt;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return (h >>> 0) / 2 ** 32;
}

function deterministicCoords(id: string) {
  const x = hashToUnit(id, 'x');
  const y = hashToUnit(id, 'y');
  const gx = Math.round(x * 11) / 11;
  const gy = Math.round(y * 7) / 7;
  return { x: gx, y: gy };
}

function pick<T = any>(obj: Record<string, any>, keys: string[]): T | undefined {
  for (const k of keys) {
    if (obj[k] !== undefined && obj[k] !== null) return obj[k];
  }
  return undefined as any;
}

async function fetchBaseTopicos(req: NextRequest) {
  const url = new URL(req.url);
  const limit = url.searchParams.get('limit') ?? '50';
  const origin = url.origin;
  const v1 = new URL('/api/topicos', origin);
  v1.searchParams.set('limit', limit);
  v1.searchParams.set('raw', '1');
  v1.searchParams.set('__skipRewrite', '1'); // evita loop middleware

  const res = await fetch(v1.toString(), { headers: { Accept: 'application/json' }, cache: 'no-store' });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`v1_fetch_failed ${res.status}: ${text}`);
  }
  const data = await res.json();
  const rows: BaseRow[] = Array.isArray(data) ? data : Array.isArray((data as any).rows) ? (data as any).rows : [];
  return rows;
}

function mapToV2(row: BaseRow): TopicoV2 {
  const id = pick<string>(row, ['id', 'topic_id', 'post_id', 'topico_id']) ?? '';
  const nombre = pick<string>(row, ['nombre', 'topic', 'topico', 'hashtag', 'name']) ?? '';
  const volumen = Number(pick<number | string>(row, ['volumen', 'volume', 'mentions', 'count']) ?? 0) || 0;
  const categoria = pick<string>(row, ['categoria', 'category', 'tipo', 'class']) ?? '';
  const pilar = pick<string>(row, ['pilar', 'pilarAsociado', 'pilar_asociado', 'pillar']) ?? '';
  const xRaw = pick<number>(row, ['x', 'coord_x', 'pos_x']);
  const yRaw = pick<number>(row, ['y', 'coord_y', 'pos_y']);
  const coords = typeof xRaw === 'number' && typeof yRaw === 'number' ? { x: xRaw, y: yRaw } : undefined;
  return { id: String(id), nombre: String(nombre), volumen, categoria: String(categoria), pilar: String(pilar), coords };
}

async function tryEnrichment(origin: string, t: TopicoV2, apiKey?: string) {
  if (t.coords && typeof t.coords.x === 'number' && typeof t.coords.y === 'number') return t;

  const mock = process.env.ENRICHMENT_MOCK === '1';
  if (mock) return { ...t, coords: deterministicCoords(t.id || t.nombre) };

  try {
    const res = await fetch(`${origin}/api/enrichment`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(apiKey ? { Authorization: `Bearer ${apiKey}` } : {}),
      },
      body: JSON.stringify({ type: 'coords', entity: 'topico', entity_id: t.id || t.nombre }),
    });
    if (!res.ok) throw new Error(`enrichment_http_${res.status}`);
    const payload = await res.json().catch(() => ({} as any));
    const x = payload?.coords?.x;
    const y = payload?.coords?.y;
    if (typeof x === 'number' && typeof y === 'number') return { ...t, coords: { x, y } };
    return { ...t, coords: deterministicCoords(t.id || t.nombre) };
  } catch {
    return { ...t, coords: deterministicCoords(t.id || t.nombre) };
  }
}

export async function GET(req: NextRequest) {
  const url = new URL(req.url);
  const dryrun = url.searchParams.get('dryrun') === '1';
  if (dryrun) return NextResponse.json({ ok: true, route: '/api/topicos/v2', dryrun: true, test: 1 });

  try {
    const base = await fetchBaseTopicos(req);
    const mapped = base.map(mapToV2);

    const origin = url.origin;
    const apiKey = process.env.API_KEY;
    const enriched = await Promise.all(mapped.map((t) => tryEnrichment(origin, t, apiKey)));

    // Adapter back-compat: aplanar coords y exponer alias usados por la UI
    const rowsOut = enriched.map((t) => ({
      id: t.id,
      nombre: t.nombre,
      volumen: t.volumen,
      volume: t.volumen,                // alias
      categoria: t.categoria,
      pilar: t.pilar,
      pilarAsociado: t.pilar,           // alias legacy
      x: t.coords?.x,
      y: t.coords?.y,
      coords: t.coords || null,
    }));

    return NextResponse.json({
      count: rowsOut.length,
      rows: rowsOut,
      source: 'v2',
      schema: ['id','nombre','volumen','volume(alias)','categoria','pilar','pilarAsociado','x','y','coords{x,y}'],
      enrichment: {
        attempted: true,
        mock: process.env.ENRICHMENT_MOCK === '1',
        provider: process.env.ENRICHMENT_MOCK === '1' ? 'deterministic' : '/api/enrichment',
      },
    }, { status: 200 });
  } catch (err: any) {
    return NextResponse.json({
      ok: false,
      error: String(err?.message || err || 'unknown_error'),
      hint: 'Verifica que /api/topicos (v1) responde y que BIGQUERY_* credenciales están configuradas. Usa ?dryrun=1 para prueba rápida.',
    }, { status: 500 });
  }
}
