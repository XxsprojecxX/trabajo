# === ORGANIZADOR AUTOMÁTICO DESDE JSON (SAFE) ===
# Uso:
#   1) Pega todo esto en la raíz del repo
#   2) bash organiza_desde_json.sh           # dry-run (no escribe)
#   3) bash organiza_desde_json.sh --apply   # aplica cambios en nueva carpeta

cat > organiza_desde_json.sh <<'EOS'
#!/usr/bin/env bash
set -euo pipefail

JSON_FILE="architecture.json"
OUT_ROOT="gmx_refactor_$(date +%Y%m%d_%H%M%S)"
APPLY=0

# ---- args ----
if [[ "${1:-}" == "--apply" ]]; then
  APPLY=1
fi

# ---- prerequisites ----
need() { command -v "$1" >/dev/null 2>&1 || { echo "Falta $1. Instala y reintenta."; exit 1; }; }
need jq

# ---- write JSON (si no existe) ----
if [[ ! -f "$JSON_FILE" ]]; then
  cat > "$JSON_FILE" <<'JEND'
REEMPLAZA_ESTE_BLOQUE_CON_TU_JSON_COMPLETO
JEND
  echo ">> Se creó $JSON_FILE. Pega tu JSON (el que me enviaste) reemplazando REEMPLAZA_ESTE_BLOQUE_CON_TU_JSON_COMPLETO."
  exit 0
fi

echo ">> Validando $JSON_FILE ..."
jq -e . "$JSON_FILE" >/dev/null

# ---- parse de nodos clave ----
NEXT_PATH=$(jq -r '.nodes[] | select(.id=="frontend_app") | .path' "$JSON_FILE")
API_PATH=$(jq -r '.nodes[] | select(.id=="api_next") | .path' "$JSON_FILE")
MID_PATH=$(jq -r '.nodes[] | select(.id=="middleware") | .path' "$JSON_FILE")
declare -a PAGES
readarray -t PAGES < <(jq -r '.nodes[] | select(.id=="frontend_app") | .pages[]' "$JSON_FILE")
declare -a ROUTES
readarray -t ROUTES < <(jq -r '.nodes[] | select(.id=="api_next") | .routes[]' "$JSON_FILE")
declare -a ENV_FRONT
readarray -t ENV_FRONT < <(jq -r '.nodes[] | select(.id=="env_front") | .vars[]' "$JSON_FILE")
declare -a ENV_BACK
readarray -t ENV_BACK < <(jq -r '.nodes[] | select(.id=="env_backend") | .vars[]' "$JSON_FILE")
declare -a VIEWS
readarray -t VIEWS < <(jq -r '.nodes[] | select(.id=="gcp_bq") | .views_expected[]' "$JSON_FILE")

[[ -z "$NEXT_PATH" || -z "$API_PATH" || -z "$MID_PATH" ]] && { echo "JSON incompleto: falta frontend_app.path, api_next.path o middleware.path"; exit 1; }

echo ">> Plan:"
echo "   - Nueva carpeta: $OUT_ROOT"
echo "   - Frontend path (origen): $NEXT_PATH"
echo "   - API path (origen): $API_PATH"
echo "   - Middleware (origen): $MID_PATH"
echo "   - Páginas (${#PAGES[@]}): ${PAGES[*]}"
echo "   - Rutas (${#ROUTES[@]}): ${ROUTES[*]}"

# ---- helpers ----
mkdirp() { [[ "$APPLY" -eq 1 ]] && mkdir -p "$1" || echo "[dry] mkdir -p $1"; }
copy_safe() {
  local src="$1" dst="$2"
  if [[ "$APPLY" -eq 1 ]]; then
    rsync -av --relative "$src" "$dst" 2>/dev/null || true
  else
    echo "[dry] rsync -av --relative $src $dst"
  fi
}
write_file() {
  local path="$1"; shift
  if [[ "$APPLY" -eq 1 ]]; then
    mkdir -p "$(dirname "$path")"
    printf "%s\n" "$*" > "$path"
  else
    echo "[dry] write $path"
  fi
}

# ---- estructura base destino ----
DST_FRONT="$OUT_ROOT/frontend"
DST_API="$DST_FRONT/app/api"
DST_APP="$DST_FRONT/app"
DST_MISC="$OUT_ROOT/_artifacts"

mkdirp "$DST_FRONT"
mkdirp "$DST_API"
mkdirp "$DST_APP"
mkdirp "$DST_MISC"

# ---- copiar middleware ----
if [[ -f "$MID_PATH" ]]; then
  copy_safe "$MID_PATH" "$DST_FRONT/"
else
  echo "WARN: No encontré $MID_PATH"
fi

# ---- copiar páginas declaradas (si existen) ----
for page in "${PAGES[@]}"; do
  # normaliza "/dashboard" -> "dashboard/page.tsx"
  CLEAN="${page%% *}"                 # quita comentarios (home)
  CLEAN="${CLEAN#/}"                  # sin slash inicial
  [[ -z "$CLEAN" || "$CLEAN" == "(home)" ]] && CLEAN=""
  TARGET_DIR="$DST_APP"
  SRC_CANDIDATES=()
  if [[ -n "$CLEAN" ]]; then
    TARGET_DIR="$DST_APP/$CLEAN"
    SRC_CANDIDATES+=("$NEXT_PATH/$CLEAN/page.tsx" "$NEXT_PATH/$CLEAN/page.ts")
  else
    SRC_CANDIDATES+=("$NEXT_PATH/page.tsx" "$NEXT_PATH/page.ts")
  fi
  mkdirp "$TARGET_DIR"
  HIT=0
  for s in "${SRC_CANDIDATES[@]}"; do
    if [[ -f "$s" ]]; then copy_safe "$s" "$TARGET_DIR/"; HIT=1; break; fi
  done
  [[ "$HIT" -eq 0 ]] && echo "WARN: No encontré fuente para página '$page' (busqué: ${SRC_CANDIDATES[*]})"
done

# ---- copiar rutas API (si existen) ----
for route in "${ROUTES[@]}"; do
  # ejemplo: /api/insights -> app/api/insights/route.ts
  NAME="${route#/api/}"           # insights, topicos/v2, etc.
  DEST_DIR="$DST_API/$NAME"
  mkdirp "$DEST_DIR"
  SRC1="$API_PATH/$NAME/route.ts"
  SRC2="$API_PATH/$NAME/route.js"
  if [[ -f "$SRC1" ]]; then
    copy_safe "$SRC1" "$DEST_DIR/"
  elif [[ -f "$SRC2" ]]; then
    copy_safe "$SRC2" "$DEST_DIR/"
  else
    echo "WARN: No encontré route para '$route' (busqué: $SRC1 | $SRC2)"
  fi
done

# ---- zona de artefactos/no-producción (separar del deploy) ----
for noisy in ".next" "node_modules" "*/*.bak" "*.bak" "app/*/_bak" "app/*/*.bak" ; do
  if compgen -G "$noisy" > /dev/null; then
    if [[ "$APPLY" -eq 1 ]]; then
      rsync -a --relative $noisy "$DST_MISC/" 2>/dev/null || true
    else
      echo "[dry] rsync -a --relative $noisy $DST_MISC/"
    fi
  fi
done

# ---- .env.template y verificador ----
ENV_TEMPLATE="$OUT_ROOT/.env.template"
ENV_VERIFY="$OUT_ROOT/env-verify.sh"

# frontend vars
ENV_FRONT_BLOCK="# FRONTEND
NEXT_PUBLIC_BASE_URL=http://localhost:3000
# TOPICOS_VIEW=v2    # opcional para middleware
"
# backend vars (minimos)
ENV_BACK_BLOCK="# BACKEND (Next API / BigQuery)
GOOGLE_PROJECT_ID=
GOOGLE_APPLICATION_CREDENTIALS=./keys/service-account.json
BQ_LOCATION=US
GOOGLE_DATASET=gmx
GOOGLE_TABLE=vw_social_post_with_pilar

TOPICOS_VIEW_V2=gmx.vw_topicos_v2
COMMENTS_VIEW_FQN=gmx.vw_comments_app_api_latest

# Sheets (si usas /api/ig)
IG_SHEET_ID=
IG_SHEET_TAB=ig_master

# Extras
EMBEDDINGS_PROVIDER_ORDER=openai,vertex,local
API_KEY=
ENRICHMENT_MOCK=0
"
write_file "$ENV_TEMPLATE" "$ENV_FRONT_BLOCK" "" "$ENV_BACK_BLOCK"

# verificador (versión compacta)
write_file "$ENV_VERIFY" '#!/usr/bin/env bash
set -euo pipefail
source ./.env 2>/dev/null || true
ok=1
req=(NEXT_PUBLIC_BASE_URL GOOGLE_PROJECT_ID GOOGLE_APPLICATION_CREDENTIALS BQ_LOCATION TOPICOS_VIEW_V2)
echo "== ENV CHECK ==" 
for v in "${req[@]}"; do
  val="${!v:-}"
  if [[ -z "$val" ]]; then echo "FALTA: $v"; ok=0; else echo "OK: $v=${val:0:6}…"; fi
done
echo "Vista efectiva TOPICOS_VIEW_V2=${TOPICOS_VIEW_V2:-gmx.vw_topicos_v2}"
exit $((1-ok))'

if [[ "$APPLY" -eq 1 ]]; then
  chmod +x "$ENV_VERIFY"
fi

# ---- README wiring ----
README="$OUT_ROOT/README_WIRING.md"
write_file "$README" "# GMX Refactor (auto)
- Arquitectura: ver $JSON_FILE
- Front: $DST_FRONT/app
- API:   $DST_FRONT/app/api
- Middleware: $DST_FRONT/middleware.ts (si fue copiado)
- Env base: .env.template (copiar a .env y completar)
- Verificador: ./env-verify.sh (ejecútalo dentro de $OUT_ROOT)

## BQ Vistas esperadas
$(printf -- "- %s\n" "${VIEWS[@]}")

## Comandos sugeridos
cd $OUT_ROOT && cp .env.template .env && ./env-verify.sh
"

echo
if [[ "$APPLY" -eq 1 ]]; then
  echo "✅ Hecho. Nueva estructura en: $OUT_ROOT"
  echo "Siguiente: cd $OUT_ROOT && cp .env.template .env && ./env-verify.sh"
else
  echo "🧪 Dry-run completo. Repite con: bash organiza_desde_json.sh --apply"
fi
EOS

chmod +x organiza_desde_json.sh